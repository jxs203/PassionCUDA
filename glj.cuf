!
!     This file contains the gljcuda kernel to write the forces, and append the potential energy
!     to the global device memory.
!     Using the thread and threadblock ids it can work out the pairwise calculation the thread
!     should be calculating.
!
! Main routine
!
module gljcuda
  implicit none

contains
  !This is !NOT! a real subroutine, but a list of things that will need to go into the main kernel that will call the potential
  !and move functions.
  attributes(global) subroutine manager(tid_d)!,NPART)
    integer :: tid_d
    integer :: ThreadBlockPerParticle
    integer :: NPART
    NPART = 200
    ThreadBlockPerParticle = CEILING(REAL(NPART)/REAL(blockDim%x)) ! rounded up number of thread blocks per particle. eg 65/32 = 2.02... -> 3.
    write(*,*) "threadidx%x",threadidx%x
    !write(*,*) "blockDim%x", blockDim%x
    write(*,*) "hello world"
    tid_d = ThreadBlockPerParticle
    ! This is worked out here because it will be constant for the entire simulation. It should be worked out outside the main loop.

  end subroutine manager

! attributes device because it can only be called from another device kernel (as opposed to global)
  attributes(device) subroutine glj(ThreadBlockPerParticle)
    implicit none
    !integer, value, intent(in)                 :: size_aa ! We can pass by value rather than by reference using the value keyword
    !integer, dimension(size_aa), intent(inout) :: aa

    integer, intent(in) :: ThreadBlockPerParticle ! The number of threads each particle will need. TODO make const
    print*, ThreadBlockPerParticle
  end subroutine glj
end module gljcuda